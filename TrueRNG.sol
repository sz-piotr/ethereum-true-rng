pragma solidity ^0.4.0;

/// @title DAO that uses input from participants to generate random numbers.
contract TrueRNG {

    struct Participant {
        uint mask; // Bitmask created from xoring all of the participants inputs.
        uint balance; // Balance in wei.
        uint bountyIndex; // The last index that the participant set bounty on.
    }

    mapping (address => Participant) public participants;
    // Maps indices to bounties.
    mapping (uint => uint) public bounties;
    // Stores all the generated numbers.
    uint[] public numbers;

    /// Create a new TrueRNG DAO.
    function TrueRNG() public {
        // The contribute function requires a value to be present in the numbers array.
        numbers.push(0);
    }

    /// Submit a random number and request another one to be generated by placing a bounty.
    function contribute(uint _submittedNumber, uint _bountyOffset) public payable returns (uint) {
        require(_bountyOffset > 0);

        Participant storage sender = participants[msg.sender];
        // Cannot submit a new random number before the bountyIndex is reached.
        // This is because it would make it impossible to consume the number that
        // the participant requested previously.
        require(sender.bountyIndex <= numbers.length);

        // The new random number is created by xoring the last one with the submitted one.
        numbers.push(numbers[numbers.length - 1] ^ _submittedNumber);

        // The mask is also xored ensuring that the sender cannot affect its own number.
        sender.mask ^= _submittedNumber;

        // Reward the bounty for submitting the number.
        sender.balance += bounties[numbers.length];

        // Create a bounty of your own. That bounty can be 0!
        sender.bountyIndex += numbers.length + _bountyOffset;
        bounties[sender.bountyIndex] += msg.value;

        return sender.bountyIndex;
    }

    /// Retrieve a random number that you placed a bounty on. It is only possible to do
    /// this before you request another number.
    function myNumber(uint _atIndex) public view returns (uint) {
        Participant storage sender = participants[msg.sender];
        require(sender.bountyIndex == _atIndex && _atIndex > 0);
        return numbers[sender.bountyIndex] ^ sender.mask;
    }

    function myBalance() public view returns (uint) {
        return participants[msg.sender].balance;
    }

    function withdraw() public {
        Participant storage sender = participants[msg.sender];
        uint amount = sender.balance;
        sender.balance = 0;
        msg.sender.transfer(amount);
    }
}
